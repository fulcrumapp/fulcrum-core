{"version":3,"sources":["../../src/elements/condition.js"],"names":["Condition","element","attributes","fieldKey","field_key","operator","value","isEqual","formValue","stringValue","TextUtils","isEmpty","contains","startsWith","isLessThan","isGreaterThan","shouldElementBeVisible","record","values","visibilityCache","key","cache","shouldBeVisible","shouldElementBeVisibleRecursive","isSectionElement","hasVisibleChildren","elements","childElement","visible","overrideIsHidden","isHidden","hasHiddenParent","hasVisibilityConditions","visibleConditionsType","visibleConditions","condition","isSatisfied","parentsVisible","iterator","parent","parentVisible","result","shouldElementBeRequired","hasRequiredConditions","overrideIsRequired","isRequired","shouldBeRequired","requiredConditionsType","requiredConditions","valueForCondition","statusValue","get","elementForCondition","form","elementsByKey","toJSON","referencedElement","isReferencedFieldSatisfied","skipElement","_isSatisfied"],"mappings":"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","sourcesContent":["import TextUtils from '../utils/text-utils';\n\nexport default class Condition {\n  constructor(element, attributes) {\n    this.element = element;\n    this.fieldKey = attributes.field_key;\n    this.operator = attributes.operator;\n    this.value = attributes.value;\n  }\n\n  static isEqual(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isEqual(stringValue);\n  }\n\n  static isEmpty(formValue) {\n    return formValue == null || formValue.isEmpty;\n  }\n\n  static contains(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.contains(stringValue);\n  }\n\n  static startsWith(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.startsWith(stringValue);\n  }\n\n  static isLessThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isLessThan(stringValue);\n  }\n\n  static isGreaterThan(formValue, stringValue) {\n    if (formValue == null) {\n      return TextUtils.isEmpty(stringValue);\n    }\n    return formValue.isGreaterThan(stringValue);\n  }\n\n  static shouldElementBeVisible(element, record, values, visibilityCache) {\n    if (visibilityCache != null && visibilityCache[element.key] != null) {\n      return visibilityCache[element.key];\n    }\n\n    const cache = visibilityCache || {};\n\n    let shouldBeVisible = Condition.shouldElementBeVisibleRecursive(element, record, values, cache);\n\n    if (element.isSectionElement) {\n      let hasVisibleChildren = false;\n\n      for (const childElement of element.elements) {\n        const visible = Condition.shouldElementBeVisibleRecursive(childElement, record, values, cache);\n\n        if (visible) {\n          hasVisibleChildren = true;\n          break;\n        }\n      }\n\n      shouldBeVisible = shouldBeVisible && hasVisibleChildren;\n    }\n\n    return shouldBeVisible;\n  }\n\n  static shouldElementBeVisibleRecursive(element, record, values, cache) {\n    if (cache != null && cache[element.key] != null) {\n      return cache[element.key];\n    }\n\n    // break circular conditions by assigning an early `true` value so if this\n    // method is re-entered again for the same element before the recursion\n    // ends, it early exits instead of blowing the stack\n    cache[element.key] = true;\n\n    // if the override value is set, always return it (SETHIDDEN() always wins)\n    if (element.overrideIsHidden != null) {\n      cache[element.key] = !element.isHidden;\n      return !element.isHidden;\n    }\n\n    if (element.isHidden || element.hasHiddenParent) {\n      cache[element.key] = false;\n      return false;\n    }\n\n    let shouldBeVisible = false;\n\n    if (!element.hasVisibilityConditions) {\n      shouldBeVisible = true;\n    }\n\n    if (element.visibleConditionsType === 'any') {\n      for (const condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeVisible = true;\n          break;\n        }\n      }\n    } else if (element.visibleConditionsType === 'all') {\n      shouldBeVisible = true;\n\n      for (const condition of element.visibleConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeVisible = false;\n        }\n      }\n    }\n\n    // Make sure all parent elements are also visible according to these same rules.\n    // If a section is hidden because of a rule, all child elements are implicitly hidden\n    // and should return NO from this method. This makes it very easy to determine value relevance\n    // by looking at only the field values without having to worry about Section elements and\n    // dependencies. See clearInvisibleValuesWithConditionValues for usage of this method that\n    // relies on this behavior.\n\n    let parentsVisible = true;\n\n    let iterator = element.parent;\n\n    while (iterator != null) {\n      const parentVisible = Condition.shouldElementBeVisibleRecursive(iterator, record, values, cache);\n\n      if (!parentVisible) {\n        parentsVisible = false;\n        break;\n      }\n\n      iterator = iterator.parent;\n    }\n\n    const result = parentsVisible && shouldBeVisible;\n\n    cache[element.key] = result;\n\n    return result;\n  }\n\n  static shouldElementBeRequired(element, record, values) {\n    // If there are no conditions, or if the override value is set, always return\n    // the current required flag. (SETREQUIRED() always wins)\n    if (!element.hasRequiredConditions || element.overrideIsRequired != null) {\n      return element.isRequired;\n    }\n\n    const cache = {};\n\n    let shouldBeRequired = false;\n\n    if (element.requiredConditionsType === 'any') {\n      for (const condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (isSatisfied) {\n          shouldBeRequired = true;\n          break;\n        }\n      }\n    } else if (element.requiredConditionsType === 'all') {\n      shouldBeRequired = true;\n\n      for (const condition of element.requiredConditions) {\n        const isSatisfied = condition.isSatisfied(record, values, cache);\n\n        if (!isSatisfied) {\n          shouldBeRequired = false;\n          break;\n        }\n      }\n    }\n\n    return shouldBeRequired;\n  }\n\n  static valueForCondition(condition, values, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue;\n    }\n\n    return values.get(condition.fieldKey);\n  }\n\n  static elementForCondition(condition, record) {\n    if (condition.fieldKey === '@status') {\n      return record.statusValue.element;\n    }\n    return record.form.elementsByKey[condition.fieldKey];\n  }\n\n  toJSON() {\n    return {\n      field_key: this.fieldKey,\n      operator: this.operator,\n      value: this.value\n    };\n  }\n\n  isSatisfied(record, values, cache) {\n    const referencedElement = Condition.elementForCondition(this, record);\n\n    let isReferencedFieldSatisfied = true;\n\n    if (referencedElement != null) {\n      // If the referenced element or one its parents is explicitly marked as hidden, it's a special\n      // case and the referenced element should always be considered satisfied so that it's possible\n      // to put conditions on explicitly hidden values.\n\n      const skipElement = referencedElement.isHidden || referencedElement.hasHiddenParent;\n\n      if (!skipElement) {\n        isReferencedFieldSatisfied = Condition.shouldElementBeVisibleRecursive(referencedElement, record, values, cache);\n      }\n    }\n\n    return this._isSatisfied(record, values, isReferencedFieldSatisfied);\n  }\n\n  _isSatisfied(record, values, isReferencedFieldSatisfied) {\n    let formValue = null;\n\n    // if all of this field's conditions aren't also satisfied, treat the value as nil (empty). This has the same\n    // effect as 'clearing' invisible values by treating them as blank when their conditions aren't met, regardless\n    // of the actual preserved value in the field. If a field is invisible, its value is always nil with respect\n    // to condition logic.\n\n    if (isReferencedFieldSatisfied) {\n      formValue = Condition.valueForCondition(this, values, record);\n    }\n\n    switch (this.operator) {\n      case 'equal_to':\n        return Condition.isEqual(formValue, this.value);\n\n      case 'not_equal_to':\n        return !Condition.isEqual(formValue, this.value);\n\n      case 'is_empty':\n        return Condition.isEmpty(formValue);\n\n      case 'is_not_empty':\n        return !Condition.isEmpty(formValue);\n\n      case 'contains':\n        return Condition.contains(formValue, this.value);\n\n      case 'starts_with':\n        return Condition.startsWith(formValue, this.value);\n\n      case 'greater_than':\n        return Condition.isGreaterThan(formValue, this.value);\n\n      case 'less_than':\n        return Condition.isLessThan(formValue, this.value);\n\n      default:\n        break;\n    }\n\n    return true;\n  }\n}\n"],"file":"condition.js"}